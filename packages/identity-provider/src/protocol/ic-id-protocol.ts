/**
 * @fileoverview tools for implementing the HTTP-based Internet Computer Identity Protocol, which is mostly a profile of OpenID Connect (OIDC), which is a profile of OAuth2.
 */
import { PublicKey } from '@dfinity/agent';
import { OAuth2AccessTokenResponse } from './oauth2';
import * as oauth2 from './oauth2';
import * as assert from 'assert';
import { hexEncodeUintArray } from '../bytes';
import { DelegationChain } from '@dfinity/authentication';

export interface ICAuthenticationResponse {
  redirectURI: string;
  accessToken: string;
  tokenType: 'bearer';
  expiresIn: number;
  // @TODO - implement
  state?: string;
  // @TODO - implement
  scope?: string;
}

/**
 * RP's build this, then (logically) send it to the Identity Provider, then hope for an AuthenticationResponse in return.
 */
export interface IDPAuthenticationRequest {
  sessionIdentity: PublicKey;
  redirectUri: URL;
}

/**
 * Convert an IC-IDP-internal message to an OAuth2-compliant one.e
 * (e.g. to snake_case keys instead of JS-conventional camelCase)
 */
export function toOAuth2(message: ICAuthenticationResponse) {
  const {
    accessToken: access_token,
    expiresIn: expires_in,
    tokenType: token_type,
    redirectURI: redirect_uri,
  } = message;
  const oauth2AccessTokenResponse: OAuth2AccessTokenResponse = {
    access_token,
    expires_in,
    token_type,
    redirect_uri,
  };
  return oauth2AccessTokenResponse;
}

/**
 * Create an ic-id message from a corresponding OAuth2 message
 */
export function fromOAuth2(message: OAuth2AccessTokenResponse) {
  if (message.token_type !== 'bearer') {
    throw new Error(
      `Cannot create ICAuthenticationResponse from non-Bearer token_type OAuth2AccessTokenResponse`,
    );
  }
  const authenticationResponse: ICAuthenticationResponse = {
    accessToken: message.access_token,
    expiresIn: message.expires_in,
    tokenType: message.token_type,
    redirectURI: message.redirect_uri,
  };
  return authenticationResponse;
}

/**
 * Parse a ICAuthenticationResponse from an OAuth2 redirect_uri-targeted querystring.
 */
export function fromQueryString(searchParams: URLSearchParams): ICAuthenticationResponse {
  const oauth2AccessTokenResponse = oauth2.fromQueryString(searchParams);
  const response: ICAuthenticationResponse = fromOAuth2(oauth2AccessTokenResponse);
  return response;
}

function decodeUtf8(bytes: Uint8Array): string {
  const TextDecoder = globalThis.TextDecoder || require('util').TextDecoder;
  return new TextDecoder().decode(bytes);
}

interface IParsedBearerToken {
  publicKey: string;
  delegations: Array<{
    delegation: {
      expiration: string;
      pubkey: string;
    };
    signature: string;
  }>;
}

/**
 * Parse a Bearer token from IC IDP oauth2 AccessTokenResponse into the IC info relatd to sender_delegation
 * @param icIdpBearerToken {string} hex-encoded utf8 JSON generated by @dfinity/agent `DelegationChain.toJSON()`
 */
export function parseBearerToken(icIdpBearerToken: string): IParsedBearerToken {
  const bytes = hexToBytes(icIdpBearerToken);
  const json = decodeUtf8(bytes);
  const parsed = JSON.parse(json);
  const publicKey = parsed.publicKey as unknown;
  const delegations = parsed.delegations as unknown;
  if (typeof publicKey !== 'string') {
    throw new Error('publicKey must be a string');
  }
  assert.ok(delegations);
  const result: IParsedBearerToken = {
    publicKey,
    delegations: delegations as IParsedBearerToken['delegations'],
  };
  return parsed;
}

/** Parse a hex-string to Uint8Array of bytes */
function hexToBytes(hex: string): Uint8Array {
  const octetStringsMatch = hex.match(/.{2}/g);
  assert.ok(octetStringsMatch, 'Expected hex string to match octet pattern, but it didnt');
  const octetStrings = octetStringsMatch.map(s => s.padStart(2, '0'));
  const bytes = octetStrings.map(s => parseInt(s, 16));
  return Uint8Array.from(bytes);
  // JSON.parse((new TextDecoder).decode(Uint8Array.from(t.match(/.{2}/g).map(s => s.padStart('0', 2)).map(h => parseInt(h, 16)))))
}

/**
 * Create a Bearer Token to encode the result of IC Authentication
 */
export function createBearerToken(spec: { delegationChain: DelegationChain }): string {
  // delegationChain.toJSON | JSON.stringify | utf8Encode | hex
  const bearerToken = hexEncodeUintArray(
    new TextEncoder().encode(JSON.stringify(spec.delegationChain)),
  );
  return bearerToken;
}
