import { sha256 } from 'js-sha256';
import { ECDSAKeyIdentity, ECDSAPublicKey } from './ecdsa';

// Generated by Uint8Array(randomBytes(32)), should not change
const goldenSeed = {
  key_ops: [],
  ext: true,
  kty: 'EC',
  x: 'EaSQG1HdU7pMzMXaIjZmDGZCa2wit-JX95cuLjZXsZI',
  y: '-z31VJQ1dNFRkg-eFdet9SPatYph0OPz5vbju0eeT6o',
  crv: 'P-256',
};

const goldenPrivateKey = {
  key_ops: [],
  ext: true,
  kty: 'EC',
  x: 'wUmIVyFHanPKCknjOWlMFFr9OKSahY7p5yT1vn4D-kw',
  y: 'KhYIS2VFq98PU08q1KGYidRfEJ2qV-EUrfaRQ4XbV_4',
  crv: 'P-256',
};

const getTestKeyPair = async (): Promise<CryptoKeyPair> => {
  const privateKey = await crypto.subtle.importKey(
    'jwk',
    goldenPrivateKey,
    {
      name: 'ECDSA',
      namedCurve: 'P-256',
    },
    true,
    [],
  );
  const publicKey = await crypto.subtle.importKey(
    'jwk',
    goldenSeed,
    {
      name: 'ECDSA',
      namedCurve: 'P-256',
    },
    true,
    [],
  );
  return {
    privateKey,
    publicKey,
  };
};

describe('ECDSAPublicKey Tests', () => {
  it('can generate a public key', async () => {
    const key = await ECDSAPublicKey.generate();

    expect(Object.keys(key)).toMatchSnapshot();
  });
  test('create from an existing public key', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed);
    expect(key).toMatchSnapshot();
  });

  test('DER encoding of ECDSA keys', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed);
    expect(new Uint8Array(key.toDer())).toMatchSnapshot();
  });

  it('should resolve the same key from a DER-encoded format as from JWK', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed, { extractable: true, keyUsages: [] });

    const encoded = key.toDer();
    expect(new Uint8Array(encoded)).toMatchSnapshot();

    const decodedKey = ECDSAPublicKey.fromDer(encoded, { extractable: true, keyUsages: [] });
    expect(key.toJwk()).toEqual((await decodedKey).toJwk());
  });

  test.skip('DER decoding of invalid keys', async () => {
    //     // Too short.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '3056301006072a8648ce3d020106052b8104000a0342000401ec030acd7d1199f73ae3469329c114944e0693c89502f850bcc6bad397a5956767c79b410c29ac6f587eec84878020fdb54ba002a79b02aa153fe47b6',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('DER payload mismatch: Expected length 65 actual length 63');
    //     // Too long.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '3056301006072a8648ce3d020106052b8104000a0342000401ec030acd7d1199f73ae3469329c114944e0693c89502f850bcc6bad397a5956767c79b410c29ac6f587eec84878020fdb54ba002a79b02aa153fe47b6ffd33' +
    //             '1b42211ce',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('DER payload mismatch: Expected length 65 actual length 70');
    //     // Invalid DER-encoding.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '0693c89502f850bcc6bad397a5956767c79b410c29ac6f54fdac09ea93a1b9b744b5f19f091ada7978ceb2f045875bca8ef9b75fa8061704e76de023c6a23d77a118c5c8d0f5efaf0dbbfcc3702d5590604717f639f6f00d',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('Expected: sequence');
  });
});

describe('ECDSAKeyIdentity Tests', () => {
  test('can encode and decode to/from keyPair', async () => {
    const identity = await ECDSAKeyIdentity.generate();
    const keyPair = identity.getKeyPair();
    const identity2 = await ECDSAKeyIdentity.fromKeyPair(keyPair);
    expect(new Uint8Array(identity.getPublicKey().toDer())).toEqual(
      new Uint8Array(identity2.getPublicKey().toDer()),
    );
  });

  test('getKeyPair should return a copy of the key pair', async () => {
    const identity = await ECDSAKeyIdentity.generate();
    const keyPair = identity.getKeyPair();
    expect(keyPair.publicKey).toBeTruthy();
    expect(keyPair.privateKey).toBeTruthy();
  });

  test('message signature is valid', async () => {
    const identity = await ECDSAKeyIdentity.generate();
    const message = 'Hello world. ECDSA test here';
    const challenge = new TextEncoder().encode(message);
    const signature = await identity.sign(challenge);
    const hash = sha256.create();
    hash.update(challenge);
    const isValid = await crypto.subtle.verify(
      {
        name: 'ECDSA',
        hash: { name: 'SHA-256' },
      },
      identity.getKeyPair().publicKey,
      signature,
      challenge,
    );
    expect(isValid).toBe(true);
  });
});
