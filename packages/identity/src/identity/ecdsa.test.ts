import { sha256 } from 'js-sha256';
import { ECDSAKeyIdentity, ECDSAPublicKey } from './ecdsa';
import { Crypto } from '@peculiar/webcrypto';

const subtle = new Crypto().subtle;

// Generated by Uint8Array(randomBytes(32)), should not change
const goldenSeed = {
  kty: 'EC',
  crv: 'P-256',
  key_ops: [],
  ext: true,
  x: '6IT6R5WPGgc2tCZhJbLy16TFljSK-HMo5B7YPk4n3-A',
  y: 'TUJE5myib04qYxvJmM-LvYr8Vy1PxguV5eR9GQ9FguU',
};

// const subtle = (crypto.webcrypto as unknown as Crypto).subtle;

describe('ECDSAPublicKey Tests', () => {
  it('can generate a public key', async () => {
    const key = await ECDSAPublicKey.generate({
      subtleCrypto: subtle,
    });

    expect(Object.keys(key)).toMatchSnapshot();
  });
  test('create from an existing public key', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed, { subtleCrypto: subtle });
    expect(key).toMatchSnapshot();
  });

  test('DER encoding of ECDSA keys', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed, { subtleCrypto: subtle });
    expect(new Uint8Array(key.toDer())).toMatchSnapshot();
  });

  it('should resolve the same key from a DER-encoded format as from JWK', async () => {
    const key = await ECDSAPublicKey.fromJWK(goldenSeed, {
      extractable: true,
      keyUsages: [],
      subtleCrypto: subtle,
    });

    const encoded = key.toDer();
    expect(new Uint8Array(encoded)).toMatchSnapshot();

    const decodedKey = ECDSAPublicKey.fromDer(encoded, {
      extractable: true,
      keyUsages: [],
      subtleCrypto: subtle,
    });
    expect(key.toJwk()).toEqual((await decodedKey).toJwk());
  });

  test.skip('DER decoding of invalid keys', async () => {
    //     // Too short.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '3056301006072a8648ce3d020106052b8104000a0342000401ec030acd7d1199f73ae3469329c114944e0693c89502f850bcc6bad397a5956767c79b410c29ac6f587eec84878020fdb54ba002a79b02aa153fe47b6',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('DER payload mismatch: Expected length 65 actual length 63');
    //     // Too long.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '3056301006072a8648ce3d020106052b8104000a0342000401ec030acd7d1199f73ae3469329c114944e0693c89502f850bcc6bad397a5956767c79b410c29ac6f587eec84878020fdb54ba002a79b02aa153fe47b6ffd33' +
    //             '1b42211ce',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('DER payload mismatch: Expected length 65 actual length 70');
    //     // Invalid DER-encoding.
    //     expect(() => {
    //       ECDSAPublicKey.fromDer(
    //         fromHexString(
    //           '0693c89502f850bcc6bad397a5956767c79b410c29ac6f54fdac09ea93a1b9b744b5f19f091ada7978ceb2f045875bca8ef9b75fa8061704e76de023c6a23d77a118c5c8d0f5efaf0dbbfcc3702d5590604717f639f6f00d',
    //         ) as DerEncodedPublicKey,
    //       );
    //     }).toThrowError('Expected: sequence');
  });
});

describe('ECDSAKeyIdentity Tests', () => {
  test('can encode and decode to/from keyPair', async () => {
    const identity = await ECDSAKeyIdentity.generate({ subtleCrypto: subtle });
    const keyPair = identity.getKeyPair();
    const identity2 = await ECDSAKeyIdentity.fromKeyPair(keyPair, subtle);
    expect(new Uint8Array(identity.getPublicKey().toDer())).toEqual(
      new Uint8Array(identity2.getPublicKey().toDer()),
    );
  });

  test('getKeyPair should return a copy of the key pair', async () => {
    const identity = await ECDSAKeyIdentity.generate({ subtleCrypto: subtle });
    const keyPair = identity.getKeyPair();
    expect(keyPair.publicKey).toBeTruthy();
    expect(keyPair.privateKey).toBeTruthy();
  });

  test('message signature is valid', async () => {
    const identity = await ECDSAKeyIdentity.generate({ subtleCrypto: subtle });
    const message = 'Hello world. ECDSA test here';
    const challenge = new TextEncoder().encode(message);
    const signature = await identity.sign(challenge);
    const hash = sha256.create();
    hash.update(challenge);
    const isValid = await subtle.verify(
      {
        name: 'ECDSA',
        hash: { name: 'SHA-256' },
      },
      identity.getKeyPair().publicKey,
      signature,
      challenge,
    );
    expect(isValid).toBe(true);
  });
});
