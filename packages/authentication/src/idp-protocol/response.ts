import * as oauth2 from './oauth2';
import * as assert from 'assert';
import { hexToBytes } from './bytes';

export function isMaybeAuthenticationResponseUrl(url: URL) {
  return url.searchParams.has('access_token');
}

export type AuthenticationResponse = {
  type: 'AuthenticationResponse';
  accessToken: string;
  tokenType: 'bearer';
  expiresIn: number;
  state?: string;
  scope?: string;
};

function AuthenticationResponse(input: oauth2.OAuth2AccessTokenResponse): AuthenticationResponse {
  const response: AuthenticationResponse = {
    type: 'AuthenticationResponse',
    accessToken: input.access_token,
    tokenType: input.token_type || 'bearer',
    expiresIn: input.expires_in,
    state: input.state,
    scope: input.scope,
  };
  return response;
}

export function fromQueryString(searchParams: URLSearchParams): AuthenticationResponse {
  const oauth2Message = oauth2.fromQueryString(searchParams);
  if (oauth2Message && 'access_token' in oauth2Message) {
    return AuthenticationResponse(oauth2Message);
  }
  throw new Error(`Unable to create AuthenticationResponse from URLSearchParams`);
}

interface IParsedBearerToken {
  publicKey: string;
  delegations: Array<{
    delegation: {
      expiration: string;
      pubkey: string;
    };
    signature: string;
  }>;
}

/**
 * Parse a Bearer token from IC IDP oauth2 AccessTokenResponse into the IC info relatd to sender_delegation
 * @param icIdpBearerToken {string} hex-encoded utf8 JSON generated by @dfinity/agent `DelegationChain.toJSON()`
 */
export function parseBearerToken(icIdpBearerToken: string): IParsedBearerToken {
  const bytes = hexToBytes(icIdpBearerToken);
  const json = decodeUtf8(bytes);
  const parsed = JSON.parse(json);
  const publicKey = parsed.publicKey as unknown;
  const delegations = parsed.delegations as unknown;
  if (typeof publicKey !== 'string') {
    throw new Error('publicKey must be a string');
  }
  assert.ok(delegations);
  const result: IParsedBearerToken = {
    publicKey,
    delegations: delegations as IParsedBearerToken['delegations'],
  };
  return parsed;
}

function decodeUtf8(bytes: Uint8Array): string {
  const TextDecoder = globalThis.TextDecoder || require('util').TextDecoder;
  return new TextDecoder().decode(bytes);
}
