import * as oauth2 from './oauth2';
import { hexToBytes } from './bytes';

/**
 * @param url - url in which to detect an AuthenticationResponse
 * @returns whether the provided url is an AuthenticationResponse url
 */
export function isMaybeAuthenticationResponseUrl(url: URL | unknown): boolean {
  if (!(url && 'searchParams' in (url as URL))) {
    return false;
  }
  return (url as URL)?.searchParams?.has('access_token');
}

/**
 * Response from ic-id Identity Provider containing result of authentication.
 * See 'ic-id-protocol.md'.
 */
export type AuthenticationResponse = {
  type: 'AuthenticationResponse';
  accessToken: string;
  tokenType: 'bearer';
  expiresIn: number;
  state?: string;
  scope?: string;
};

function AuthenticationResponse(input: oauth2.OAuth2AccessTokenResponse): AuthenticationResponse {
  const response: AuthenticationResponse = {
    type: 'AuthenticationResponse',
    accessToken: input.access_token,
    tokenType: input.token_type || 'bearer',
    expiresIn: input.expires_in,
    state: input.state,
    scope: input.scope,
  };
  return response;
}

/**
 * Parse an AuthenticationResponse from a URL Query string.
 *
 * @param searchParams URLSearchParams from which to parse an AuthenticationResponse
 * @returns the response parsed from searchParams
 */
export function fromQueryString(searchParams: URLSearchParams): AuthenticationResponse {
  const oauth2Message = oauth2.fromQueryString(searchParams);
  if (oauth2Message && 'access_token' in oauth2Message) {
    return AuthenticationResponse(oauth2Message);
  }
  throw new Error(`Unable to create AuthenticationResponse from URLSearchParams`);
}

/**
 * Parse an AuthenticationResponse from a URL, if possible.
 * @param url - URL from which to attempt parsing an AuthenticationResponse
 * @param options options
 * @param options.allowSearch - whether to try to parse the URL 'search params' (aka query string)
 *   It's preferred for the AuthenticationResponse to be url-encoded in the URL Hash Fragment.
 *   Only use this for backward-compatability with pre-release versions of IDP.
 *   @todo (remove this affordance so no one is tempted to use query string when it's not needed and recommended against by oauth2)
 */
export function fromUrl(
  url: URL,
  options: {
    allowSearch?: boolean;
  },
): AuthenticationResponse {
  const candidates = [
    url.hash.replace(/^#/, ''),
    ...(options.allowSearch ? [url.search.replace(/^\?/, '')] : []),
  ];
  const failures: Array<{ candidate: string; error: Error }> = [];
  for (let i = 0; i < candidates.length; i++) {
    const maybeUrlEncodedString = candidates[i];
    try {
      return fromQueryString(new URLSearchParams(maybeUrlEncodedString));
    } catch (error) {
      failures.push({ error, candidate: maybeUrlEncodedString });
    }
  }
  throw Object.assign(new Error('Failed to create AuthenticationResponse from url'), {
    url,
    failures,
  });
}

interface IParsedBearerToken {
  publicKey: string;
  delegations: Array<{
    delegation: {
      expiration: string;
      pubkey: string;
    };
    signature: string;
  }>;
}

/**
 * Parse a Bearer token from IC IDP oauth2 AccessTokenResponse into the IC info related to sender_delegation
 *
 * @param icIdpBearerToken {string} hex-encoded utf8 JSON generated by @dfinity/agent `DelegationChain.toJSON()`
 * @returns parsed bearer token
 */
export function parseBearerToken(icIdpBearerToken: string): IParsedBearerToken {
  const bytes = hexToBytes(icIdpBearerToken);
  const json = decodeUtf8(bytes);
  const parsed = JSON.parse(json);
  const publicKey = parsed.publicKey as unknown;
  const delegations = parsed.delegations as unknown;
  if (typeof publicKey !== 'string') {
    throw new Error('publicKey must be a string');
  }
  if (!delegations) {
    throw new Error('delegations null');
  }
  const result: IParsedBearerToken = {
    publicKey,
    delegations: delegations as IParsedBearerToken['delegations'],
  };
  return result;
}

function decodeUtf8(bytes: Uint8Array): string {
  const TextDecoder =
    globalThis.TextDecoder ||
    /* eslint-disable-next-line @typescript-eslint/no-var-requires */
    require('util').TextDecoder;
  return new TextDecoder().decode(bytes);
}

/**
 * Convert an ic-id AuthenticationResponse to an oauth2 AccessTokenResponse.
 * This is mostly converting to underscore_case.
 * @param response - ic-id AuthenticationResponse
 */
export function toOauth(response: AuthenticationResponse): oauth2.OAuth2AccessTokenResponse {
  const oauth2Response: oauth2.OAuth2AccessTokenResponse = {
    access_token: response.accessToken,
    token_type: 'bearer',
    expires_in: response.expiresIn,
    state: response.state,
    scope: response.scope,
  };
  return oauth2Response;
}

/**
 * Create a URI that will send an AuthenticationResponse to a redirect_uri.
 * The AuthenticationResponse will be encoded as x-www-form-urlencoded, then appended
 * to the redirectUri as the entirety of the hash fragment
 * @param redirectUri - URI to send response to. Usually from AuthenticationRequest.redirectUri
 *   The endpoint URI MUST NOT include a fragment component (https://tools.ietf.org/html/rfc6749#section-3.1.2).
 * @param authenticationResponse - response to send to the redirect_uri via redirect.
 */
export function createSendResponseUri(
  redirectUri: URL,
  authenticationResponse: AuthenticationResponse,
): string {
  if (redirectUri.hash) {
    throw new Error(`redirectUri MUST NOT already have a hash fragment`);
  }
  const responseUri = (() => {
    const _responseUrl = new URL(redirectUri.toString());
    _responseUrl.hash = `#${queryStringify(toOauth(authenticationResponse), true)}`;
    return _responseUrl.toString();
  })();
  return responseUri;
}

/**
 * Given a record, return that record encoded like application/x-www-form-urlencoded
 * @param record - key/value pairs
 * @param [sortKeys=false] - whether or not to sort the keys in the returned query string.
 */
function queryStringify(
  record: Record<string, string | number | undefined>,
  sortKeys = false,
): string {
  const searchParams = new URLSearchParams();
  const recordKeys = Object.keys(record);
  if (sortKeys) {
    recordKeys.sort();
  }
  for (const key of recordKeys) {
    const value = record[key];
    if (value === null ?? value === undefined) {
      continue;
    }
    searchParams.set(key, value?.toString());
  }
  return searchParams.toString();
}
