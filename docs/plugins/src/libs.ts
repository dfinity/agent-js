import fs from 'node:fs/promises';
import path from 'node:path';
import { Application, ProjectReflection, ReflectionKind, type TypeDocOptions } from 'typedoc';
import type { StarlightPlugin } from '@astrojs/starlight/types';
import { type PluginOptions as TypeDocMarkdownOptions } from 'typedoc-plugin-markdown';

import { DOCS_DIR, TMP_DIR } from './utils/constants.ts';
import type { Frontmatter, Sidebar } from './utils/types.ts';
import { titleFromFilename, titleFromIdCapitalized } from './utils/string.ts';
import { processMarkdown } from './utils/markdown.ts';

async function generateApiDocs({
  baseDir,
  typeDoc,
}: LibsLoaderOptions): Promise<ProjectReflection> {
  const defaultTypeDocOptions: LibsLoaderTypeDocOptions = {
    entryPoints: [`${baseDir}/*`],
    entryPointStrategy: 'packages',
    packageOptions: {
      entryPoints: ['src/index.ts'],
      tsconfig: './tsconfig.json',
      readme: 'none',
    },
    plugin: ['typedoc-plugin-markdown', 'typedoc-plugin-frontmatter'],
    tsconfig: './tsconfig.typedoc.json',
    outputs: [{ name: 'markdown', path: TMP_DIR }],
    readme: 'none',
    hidePageTitle: true,
    hideBreadcrumbs: true,
    hidePageHeader: true,
  };

  const app = await Application.bootstrapWithPlugins({
    ...defaultTypeDocOptions,
    ...typeDoc,
  });

  const project = await app.convert();
  if (!project) {
    throw new Error('Failed to convert project with TypeDoc');
  }
  await app.generateOutputs(project);

  return project;
}

/**
 * Options for the LibsLoader plugin.
 */
export interface LibsLoaderOptions {
  /**
   * Base directory where the libraries are located.
   *
   * This should be a path relative to your `astro.config.mjs` file.
   */
  baseDir: string | URL;

  /**
   * Output directory for the generated documentation.
   *
   * This should be a path relative to the `src/content/docs` directory.
   * Defaults to `libs`.
   */
  outDir?: string | URL;

  /**
   * Whether to clean the output directory before generating documentation.
   *
   * Defaults to `true`.
   */
  clean?: boolean;

  /**
   * Options for TypeDoc.
   */
  typeDoc?: LibsLoaderTypeDocOptions;

  /**
   * Frontmatter applied to every markdown file generated by TypeDoc.
   */
  frontmatter?: Frontmatter;

  /**
   * Sidebar items to add before the generated sidebar items.
   */
  prependSidebar?: Sidebar;

  /**
   * Sidebar items to add after the generated sidebar items.
   */
  appendSidebar?: Sidebar;
}

export type LibsLoaderTypeDocOptions = TypeDocMarkdownOptions & TypeDocOptions;

export function libsPlugin(opts: LibsLoaderOptions): StarlightPlugin {
  return {
    name: '@dfinity/starlight/libs',
    hooks: {
      async 'config:setup'(ctx) {
        const site = ctx.astroConfig.site;
        const baseDir = path.resolve(opts.baseDir.toString());
        const outDir = path.resolve(DOCS_DIR, opts.outDir?.toString() ?? 'libs');
        const clean = opts.clean ?? true;

        if (!site) {
          throw new Error('Site URL is not defined in Astro config');
        }

        if (clean) {
          await fs.rm(outDir, { recursive: true, maxRetries: 3, force: true });
          await fs.rm(TMP_DIR, { recursive: true, maxRetries: 3, force: true });
        }

        const project = await generateApiDocs(opts);

        const librarySidebarItems = [];
        const modules = project.getChildrenByKind(ReflectionKind.Module);
        for (const { name } of modules) {
          const id = name.startsWith('@') ? name.split('/')[1]! : name;
          const outputRootDir = path.resolve(outDir, id);
          const outputApiDir = path.resolve(outputRootDir, 'api');
          const title = titleFromIdCapitalized(id);

          await processMarkdown({
            inputPath: path.resolve(baseDir, id, 'README.md'),
            outputPath: path.resolve(outputRootDir, `index.md`),
            frontmatter: {
              title,
              ...(opts?.frontmatter || {}),
            },
          });

          const apiSrcDir = path.resolve(TMP_DIR, name);
          const files = await fs.readdir(apiSrcDir, {
            withFileTypes: true,
            recursive: true,
          });
          for (const file of files) {
            if (file.isFile() && file.name.endsWith('.md')) {
              const prefix = path.relative(apiSrcDir, file.parentPath);
              const inputFileName = file.name;
              const isReadme = inputFileName.endsWith('README.md');
              const outputFileName = isReadme ? 'index.md' : inputFileName;
              const title = isReadme ? 'Overview' : titleFromFilename(file.name);

              await processMarkdown({
                inputPath: path.resolve(apiSrcDir, prefix, inputFileName),
                outputPath: path.resolve(outputApiDir, prefix, outputFileName),
                frontmatter: {
                  title,
                  ...(opts?.frontmatter || {}),
                },
              });
            }
          }

          librarySidebarItems.push({
            label: title,
            collapsed: true,
            items: [
              {
                label: 'Overview',
                link: `/libs/${id}`,
              },
              {
                label: 'API Reference',
                collapsed: true,
                autogenerate: {
                  collapsed: true,
                  directory: `libs/${id}/api`,
                },
              },
            ],
          });
        }

        ctx.updateConfig({
          sidebar: [
            ...(opts.prependSidebar || []),
            {
              label: 'Modules',
              items: librarySidebarItems,
            },
            ...(opts.appendSidebar || []),
            ...(ctx.config.sidebar || []),
          ],
        });
      },
    },
  };
}
